@(graph: String, nodeID: String)
@import helper._

<!DOCTYPE html>

<html><body>
    <style type='text/css'>
    svg {
    overflow: hidden;
    }

    .node rect {
    stroke: #333;
    stroke-width: 1.5px;
    fill: #fff;
    }

    .edgeLabel rect {
    fill: #fff;
    }

    .edgePath {
    stroke: #333;
    stroke-width: 1.5px;
    fill: none;
    }
    </style>
    <script type='text/javascript' src="http://d3js.org/d3.v3.js"></script>
    @* Originally from http://cpettitt.github.io/project/dagre-d3 *@
    <script type='text/javascript' src="@routes.Assets.at("javascripts/dagre-d3.min.js")"></script>
    @* Originally from http://cpettitt.github.io/project/graphlib-dot *@
    <script type='text/javascript' src="@routes.Assets.at("javascripts/graphlib-dot.min.js")"></script>
    <script type='text/javascript'>
    window.onload=function(){
    // Parse the DOT syntax into a graphlib object.
    var g = graphlibDot.read(@Html(graph));
    // Render the graphlib object using d3.
    // Create and configure the renderer
    var render = new dagreD3.render();
    // Set up an SVG group so that we can translate the final graph.
    var svg = d3.select("svg"),
    inner = svg.append("g");
    // Run the renderer. This is what draws the final graph.
    render(inner, g);
    // Center the graph - first, if graph bigger than svg (plus margins) then enlarge svg
    if (svg.attr("width") <= (g.graph().width + 40)) {
    svg.attr("width", g.graph().width + 40)
    }
    var xCenterOffset = (svg.attr("width") - g.graph().width) / 2;
    inner.attr("transform", "translate(" + xCenterOffset + ", 20)");
    svg.attr("height", g.graph().height + 40);    // Resize the window height as well
    // Resize the window based on the contents.
    var svg=document.querySelector('#graphContainer');
    var bbox=svg.getBBox();
    window.resizeTo(bbox.width + 60.0, bbox.height + 120.0)
    }
    </script>
    <svg id="graphContainer">
        <g/>
    </svg>
</body></html>